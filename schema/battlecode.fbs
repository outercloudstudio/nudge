namespace battlecode.schema;


struct Vec {
    x: int = 0;
    y: int = 0;
}


table VecTable {
    xs: [int];
    ys: [int];
}

enum TrapType: byte {
    RAT_TRAP,
    CAT_TRAP
}

enum RobotType: byte {
    NONE,
    RAT, // baby rat
    RAT_KING,
    CAT
}


enum WinType: byte {
    RESIGNATION,
    RATKING_DESTROYED,
    BACKSTAB_RATKING_DESTROYED,
    MORE_POINTS,
    MORE_ROBOTS,
    MORE_CHEESE,
    TIE,
    COIN_FLIP
}


enum DieType: byte {
    UNKNOWN,
    EXCEPTION
}


table RobotTypeMetadata {
    type: RobotType;
    actionCooldown: int;
    movementCooldown: int;
    turningCooldown: int;
    baseHealth: int;
    maxCheese: int;
    visionConeRadiusSquared: int;
    visionConeAngle: int;
    messageRadiusSquared: int;
    bytecodeLimit: int;
}


table TeamData {
    name: string;
    packageName: string;
    teamId: byte;
}


table GameplayConstants {
}


/// Create a Rat King at the specified location
struct CreateRatKing {
    /// center square of the rat king
    /// (all rats in the 3x3 square centered here get converted to the king)
    center: ushort;
}


/// Cat feeds on a rat
struct CatFeed {
    /// the ID of the eaten rat
    id: ushort;
}


/// Rat attacks another rat
struct RatAttack {
    /// Id of the attacked rat
    id: ushort;
}


/// Kidnap a rat
struct RatNap {
    /// Id of the napping victim
    id: ushort;
}


/// Throw a rat
struct ThrowRat {
    /// Id of the thrown rat
    id: ushort;
    loc: ushort;
}


/// Upgrade a 3x3 area of rats into a rat king
struct UpgradeToRatKing {
    /// Placeholder data bc the struct cant be empty
    phantom: ushort;
}


/// Rat Collision
struct RatCollision {
    loc: ushort;
}


/// Indicate that a dirt wall is placed
struct PlaceDirt {
    loc: ushort;
}


/// Indicate that a dirt wall is destroyed
struct BreakDirt {
    loc: ushort;
}


/// Indicate that a cheese has been picked up from the map by a rat
struct CheesePickup {
    loc: ushort;  
}


/// Spawn a cheese at a location
struct CheeseSpawn {
    loc: ushort;
    amount: ushort;
}


/// Transfer a cheese between rats
struct CheeseTransfer {
    /// Id of the rat which receives the cheese
    id: ushort;
    amount: ushort;
}


/// Cat scratch at location
struct CatScratch {
    loc: ushort;
}


/// Cat jump from start to end
struct CatPounce {
    startLoc: ushort;
    endLoc: ushort;
}


/// Place a trap at location
struct PlaceTrap {
    loc: ushort;
    team: byte;
    isRatTrapType: bool;
}

/// Remove a trap at location
struct RemoveTrap {
    loc: ushort;
    team: byte;
}

/// Triggers the trap
struct TriggerTrap {
    loc: ushort;
    team: byte;
}


/// Rat squeak action
struct RatSqueak {
    loc: ushort;
}


/// Generic action representing damage to a robot
struct DamageAction {
    /// Id of the damage target
    id: ushort;
    damage: ushort;
}


/// Action for when a robot is stunned
struct StunAction {
    id: ushort;
    cooldown: ushort;
}


/// Indicate that this robot was spawned on this turn
struct SpawnAction {
    /// Id of the bot that spawned
    id: ushort;
    x: ubyte;
    y: ubyte;
    dir: ubyte;
    chirality: ubyte;
    team: byte;
    robotType: RobotType;
}


/// Indicates that a robot died and should be removed
struct DieAction {
    /// Id of the robot that died
    id: ushort;
    dieType: DieType;
}


/// Update the indicator string for this robot
table IndicatorStringAction {
    value: string;
}


/// Update the indicator dot for this robot
struct IndicatorDotAction {
    loc: ushort;
    colorHex: int;
}


/// Update the indicator line for this robot
struct IndicatorLineAction {
    startLoc: ushort;
    endLoc: ushort;
    colorHex: int;
}


union Action {
    CatFeed,
    RatAttack,
    RatNap,
    RatCollision,
    PlaceDirt,
    BreakDirt,
    CheesePickup,
    CheeseSpawn,
    CheeseTransfer,
    CatScratch,
    CatPounce,
    PlaceTrap,
    RemoveTrap,
    TriggerTrap,
    ThrowRat,
    UpgradeToRatKing,
    RatSqueak,
    DamageAction,
    StunAction,
    SpawnAction,
    DieAction,
    IndicatorStringAction,
    IndicatorDotAction,
    IndicatorLineAction
}


/// A list of initial bodies to be placed on the map.
table InitialBodyTable {
    spawnActions: [SpawnAction];
}


table GameMap {
    name: string;
    size: Vec;
    symmetry: int; // The map symmetry: 0 for rotation, 1 for horizontal, 2 for vertical.
    initialBodies: InitialBodyTable;
    randomSeed: int;
    walls: [bool];
    dirt: [bool];
    cheese: [int];
    cheeseMines: VecTable;
    catWaypointIds: [ushort];
    catWaypointVecs: [VecTable];
}


/// Markers for events during the game indicated by the user
table TimelineMarker{
    team: byte;
    round: int;
    colorHex: int;
    label: string;
}


//========================================================================================
// Profiler tables


/// These tables are set-up so that they match closely with speedscope's file format documented at
/// https://github.com/jlfwong/speedscope/wiki/Importing-from-custom-sources.
/// The client uses speedscope to show the recorded data in an interactive interface.


/// A single event in a profile. Represents either an open event (meaning a
/// method has been entered) or a close event (meaning the method was exited).
table ProfilerEvent {
    /// Whether this is an open event (true) or a close event (false).
    isOpen: bool;
    /// The bytecode counter at the time the event occurred.
    at: int;
    /// The index of the method name in the ProfilerFile.frames array.
    frame: int;
}


/// A profile contains all events and is labeled with a name.
table ProfilerProfile {
    /// The display-friendly name of the profile.
    name: string;
    /// The events that occurred in the profile.
    events: [ProfilerEvent];
}


/// A profiler file is a collection of profiles.
/// When profiling is enabled there is one of these per team per match.
table ProfilerFile {
    /// The method names that are referred to in the events.
    frames: [string];
    /// The recorded profiles, one per robot.
    profiles: [ProfilerProfile];
}
//========================================================================================
/// Events


/// An Event is a single step that needs to be processed.
/// A saved game simply consists of a long list of Events.
/// Events can be divided by either being sent separately (e.g. as separate
/// websocket messages), or by being wrapped with a GameWrapper.
/// A game consists of a series of matches; a match consists of a series of
/// rounds, and is played on a single map. Each round is a single simulation
/// step.
union Event {
    /// There should only be one GameHeader, at the start of the stream.
    GameHeader,
    /// There should be one MatchHeader at the start of each match.
    MatchHeader,
    /// A single simulation step. A round may be skipped if
    /// nothing happens during its time.
    Round,
    /// There should be one MatchFooter at the end of each simulation step.
    MatchFooter,
    /// There should only be one GameFooter, at the end of the stream.
    GameFooter
}


/// The first event sent in the game. Contains all metadata about the game.
table GameHeader {
    specVersion: string;
    teams: [TeamData];
    robotTypeMetadata: [RobotTypeMetadata];
    constants: GameplayConstants;
}


/// The final event sent in the game.
table GameFooter {
    /// The ID of the winning team of the game.
    winner: byte;
}


/// Sent to start a match.
table MatchHeader {
    map: GameMap;
    maxRounds: int;
}


/// Sent to end a match.
table MatchFooter {
    /// The ID of the winning team.
    winner: byte;
    /// The reason for winning
    winType: WinType;
    /// The number of rounds played.
    totalRounds: int;
    /// Markers for this match.
    timelineMarkers: [TimelineMarker];
    /// Profiler data for team A and B if profiling is enabled.
    profilerFiles: [ProfilerFile];
}


table Turn {
    robotId: int;
    health: int;
    cheese: int;
    moveCooldown: int;
    turningCooldown: int;
    actionCooldown: int;
    bytecodesUsed: int;
    x: ubyte;
    y: ubyte;
    dir: ubyte;
    actions: [Action];
    isCooperation: bool;
}


/// A single time-step in a Game, which contains a list of robot turns
table Round {
    /// The IDs of teams in the Game.
    teamIds: [int];

    /// The total amount of cheese transferred per team
    teamCheeseTransferred: [int];

    /// The total number of cat damage done by each team
    teamCatDamage: [int];

    /// The total number of alive rat kings per team
    teamAliveRatKings: [int];
   
    /// The total number of alive baby rats per team
    teamAliveBabyRats: [int];

    /// The total number of live rat traps per team
    teamRatTrapCount: [int];

    /// The total number of live cat traps per team
    teamCatTrapCount: [int];

    /// The total number of live cat traps per team
    teamDirtAmounts: [int];

   
    /// Ordered turn data for each robot during the round
    turns: [Turn];

    /// The IDs of bodies that died at the end of the round, with no attributable cause.
    diedIds: [int];

    /// The first sent Round in a match should have index 1. (The starting state,
    /// created by the MatchHeader, can be thought to have index 0.)
    /// It should increase by one for each following round.
    roundId: int;
}


/// Necessary due to flatbuffers requiring unions to be wrapped in tables.
table EventWrapper {
    e: Event;
}


/// If events are not otherwise delimited, this wrapper structure
/// allows a game to be stored in a single buffer.
/// The first event will be a GameHeader; the last event will be a GameFooter.
/// matchHeaders[0] is the index of the 0th match header in the event stream,
/// corresponding to matchFooters[0]. These indices allow quick traversal of
/// the file.
table GameWrapper {
    /// The series of events comprising the game.
    events: [EventWrapper];
    /// The indices of the headers of the matches, in order.
    matchHeaders: [int];
    /// The indices of the footers of the matches, in order.
    matchFooters: [int];
}
